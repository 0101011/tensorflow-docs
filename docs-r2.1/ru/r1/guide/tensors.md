# Тензоры

Note: Вся информация в этом разделе переведена с помощью русскоговорящего
Tensorflow сообщества на общественных началах. Поскольку этот перевод не
является официальным, мы не гарантируем что он на 100% аккуратен и соответствует
[официальной документации на английском языке](https://www.tensorflow.org/?hl=en).
Если у вас есть предложение как исправить этот перевод, мы будем очень рады
увидеть pull request в [tensorflow/docs](https://github.com/tensorflow/docs)
репозиторий GitHub. Если вы хотите помочь сделать документацию по Tensorflow
лучше (сделать сам перевод или проверить перевод подготовленный кем-то другим),
напишите нам на
[docs-ru@tensorflow.org list](https://groups.google.com/a/tensorflow.org/forum/#!forum/docs-ru).

Как понятно из названия, TensorFlow ("поток тензоров") - это фреймворк для определения 
и вычисления операций с тензорами. Тензор - это обобщенное название векторов и матриц,
вплоть до потенциально высоких размерностей. Во внутренней структуре TensorFlow
векторы представлены как n-размерные массивы примитивных типов данных.

При написании программ в TensorFlow ключевым объектом всех операций является
`tf.Tensor`. Этот объект представляет собой частично определенное вычисление,
которое в конечном итоге выдаст какое-либо значение. Программы TensorFlow
сначала строят граф объектов `tf.Tensor`, детализирует как каждый тензор будет
вычисляться на других доступных тензорах, а затем запускает построение этого
графа для получения желаемых результатов.

Объект `tf.Tensor` имеет следующие параметры:


 * тип данных (например`float32`, `int32`, или `string`)
 * форму (a shape)


Каждый элемент в тензоре имеет одинаковый тип данных, и этот тип всегда известен.
Размерность, которая определяется количеством размерностей и размером каждого
массива, может быть известна частично. Большинство операций производят
тензоры полностью известных размерностей, если эти входные размерности также
известны, но в некоторых случаях узнать размерность тензора можно только в режиме
graph execution.

Некоторые типы тензоров являются специализированными, и будут описаны в
других статьях руководства по TensorFlow. Ключевыми являются:

  * `tf.Variable`
  * `tf.constant`
  * `tf.placeholder`
  * `tf.SparseTensor`


За исключением `tf.Variable`, значение тензора является неизменным, что означает
в контексте единичного вычисления тензор будет иметь всего одно значение. Однако,
при вычислении одного и того же тензора дважды, он может возвращать разные значения;
например, тензор может быть результатом прочтения данных с диска, или случайно
сгенерированного числа.


## Ранг


**Ранг** объекта `tf.Tensor` - это количество размерностей массива. Синонимами
ранга являются **порядок**, **степень** или **n-размерность**.
Обрати внимание, что ранг в TensorFlow это не то же самое, что ранг матрицы в
математике. Из следующей таблицы видно, что каждый ранг в TensorFlow соответствует
разным математическим категориям:


Ранг | Математическая категория
--- | ---
0 | Скаляр (только величина)
1 | Вектор (величина и направление)
2 | Матрица (таблица чисел)
3 | 3-Тензор (куб чисел)
n | n-Тензор (ты понял идею)


### Ранг 0

Следующий пример кода демонстрирует создание нескольких переменных
ранга 0:

```python
mammal = tf.Variable("Elephant", tf.string)
ignition = tf.Variable(451, tf.int16)
floating = tf.Variable(3.14159265359, tf.float64)
its_complicated = tf.Variable(12.3 - 4.85j, tf.complex64)
```


Обрати внимание: строка в TensorFlow является одним объектом, а не последовательностью
символов. Возможно также использовать скалярные строки, вектор строк и так далее.

### Ранг 1


Чтобы создать объект `tf.Tensor` ранга 1, ты можешь передать список элементов
как первичное значение. Например:

```python
mystr = tf.Variable(["Hello"], tf.string)
cool_numbers  = tf.Variable([3.14159, 2.71828], tf.float32)
first_primes = tf.Variable([2, 3, 5, 7, 11], tf.int32)
its_very_complicated = tf.Variable([12.3 - 4.85j, 7.5 - 6.23j], tf.complex64)
```


### Высшие ранги


Ранг 2 объекта `tf.Tensor` состоит из как минимум одного ряда и одного
столбца:

```python
mymat = tf.Variable([[7],[11]], tf.int16)
myxor = tf.Variable([[False, True],[True, False]], tf.bool)
linear_squares = tf.Variable([[4], [9], [16], [25]], tf.int32)
squarish_squares = tf.Variable([ [4, 9], [16, 25] ], tf.int32)
rank_of_squares = tf.rank(squarish_squares)
mymatC = tf.Variable([[7],[11]], tf.int32)
```


Тензоры высшего ранга подобным образом состоят из n-размерных массивов. Например,
во время обработки изображения используются тензоры ранга 4 с соответствующими
им размерносятми примеров в батче, шириной и высотой изображения, и цветовой модели.

``` python
my_image = tf.zeros([10, 299, 299, 3])  # batch x height x width x color
```

### Получаем ранг объекта `tf.Tensor`


Чтобы определить ранг объекта `tf.Tensor`, вызови метод `tf.rank`. Например,
следующий метод программным способом определит ранг `tf.Tensor`, определенного
в предыдущем блоке кода:

```python
r = tf.rank(my_image)
# После запуска графа, r присвоится значение 4.
```

### Работаем с частями `tf.Tensor`


Поскольку `tf.Tensor` является n-размерным массивом элементов, то для доступа к
конкретному элементу `tf.Tensor` потребуется уточнить индексы n.


Для тензора ранг 0 (скаляра) не требуется никаких индексов, посколько это
и есть одно единственное значение.


Для тензора ранга 1 (вектора) потребуется передать всего один индекс, который
предоставит нам доступ к значению:


```python
my_scalar = my_vector[2]
```


Обрати внимание, что индекс, передаваемый внутри `[]`, может сам быть скалярным
`tf.Tensor`, если ты хочешь динамически выбирать элементы из вектора.


С тензорами ранга 2 и выше ситуация более интересная. Передавая два значения
`tf.Tenosor` ранга 2, он возвращает скаляр, что вполне ожидаемо:


```python
my_scalar = my_matrix[1, 2]
```


Однако, передавая одно единственное значение, он возвращает подвектор матрицы как
в этом примере:


```python
my_row_vector = my_matrix[2]
my_column_vector = my_matrix[:, 3]
```


Нотация `:` в Python делит синтаксис, оставляя эту размерность "в покое". Этот
прием полезен при работе с тензорами высшего ранга, поскольку предоставляет
доступ к его подвекторам, подматрицам и даже подтензорам.


## Форма


**Форма** тензора - это количество элементов в каждой размерности.
TensorFlow автоматически назначает формы во время работы в graph execution.
Назначенные формы могут иметь известный или неизвестный ранг. Если ранг
известен, то элементы каждой размерности также могут быть известны или
неизвестны.


В документации TensorFlow используются три правила для описания размерности
тензоров: ранг, форма и номер размерности. В следующией таблице видно, как эти
три параметра соотносятся друг с другом:

Ранг | Форма | Номер размерности | Пример
--- | --- | --- | ---
0 | [] | 0-D | Тензор 0-D .  Скаляр.
1 | [D0] | 1-D | Тензор 1-D формы [5].
2 | [D0, D1] | 2-D | Тензор 2-D формы [3, 4].
3 | [D0, D1, D2] | 3-D | Тензор 3-D формы [1, 4, 3].
n | [D0, D1, ... Dn-1] | n-D | Тензор формы [D0, D1, ... Dn-1].


Формы могут быть представлены в Python как списки или кортежи целых чисел,
или как `tf.TensorShape`

### Получаем форму объекта `tf.Tensor`


Есть два способа получить форму `tf.Tensor`. Во время построения графа часто
является полезным узнать, что уже известно о форме тензора. Это можно сделать
прочтя параметр `shape` объека `tf.Tensor`. Этот метод возвращает объект
`TensorShape`, который является весьма удобным способом представления
частично определенных форм, поскольку во время построения графа не все формы
известны полностью.


Также возможно получить `tf.Tensor`, который будет представлять полностью
определенную форму другого объекта `tf.Tensor` в рабочей среде. Это достигается
путем вызова операции `tf.shape`. Таким образом ты можешь построить граф, который
манипулирует формами тензоров при помощи создания других тензоров, который зависят
от динамической формы входящего `tf.Tensor`.


Например, вот как мы можем сделать вектор из нулей с одинаковым размером и числом
столбцов в матрице:

``` python
zeros = tf.zeros(my_matrix.shape[1])
```


### Изменяем форму `tf.Tensor`


**Количество элементов** тензора - это продукт размеров всех форм. Количество
элементов - это скаляр, который всегда равен `1`. Посколько часто множесто разных
форм имеют одинаковое количество элементов, то часто удобно позволять менять форму
`tf.Tensor`, зафиксировав его элементы. Это можно сделать с помощью `tf.reshape`.

В следующем примере показано как изменить форму тензоров:

```python
rank_three_tensor = tf.ones([3, 4, 5])
matrix = tf.reshape(rank_three_tensor, [6, 10])  # Изменяем существующую форму на
                                                 # матрицу 6x10
matrixB = tf.reshape(matrix, [3, -1])  #  Изменяем форму на матрицу 3х20.
                                       # -1 требует `reshape` рассчитать
                                       # размерность тензора.
matrixAlt = tf.reshape(matrixB, [4, 3, -1])  # Изменяем форму на
                                             # тензор 4х3х5

# Обрати внимание, что количество элементов измененных тензоров должно совпадать
# с изначальным количеством элементов. Таким образом, следующий пример выдает
# ошибку, так как нет значения для последней размерности, которое бы совпадало
# с количеством элементов.
yet_another = tf.reshape(matrixAlt, [13, 2, -1])  # Ошибка!
```

## Типы данных


В дополнение к размерностям, тензоры имеют тип данных. Смотри документацию
`tf.DType` для ознакомления с полным списком типов данных.


Невозможно иметь `tf.Tensor` более чем с одним типом данных. Тем не менее, возможно
сериализовать произвольные структуры данных как строки и сохранить их в `tf.Tensor`.


Также возможно конвертировать тип данных из одного `tf.Tensor` в другой при помощи
метода `tf.cast`:


``` python
# Переводим константу тензора в число с плавающей запятой.
float_tensor = tf.cast(tf.constant([1, 2, 3]), dtype=tf.float32)
```


Для проверки тип данных `tf.Tensor` используй параметр `Tensor.dtype`.


При создании `tf.Tensor` из объекта Python, ты можешь также указать тип данных
этого тензора. Если этого не сделать, то TensorFlow сам выберет тип данных, 
который будет представлять твои данные. TensorFlow автоматически конвертирует
*целые числа* Python в `tf.int32`, а *числа с плавающей запятой* - в `tf.float32`.
Другими словами, TensorFlow использует те же самые правила, что и NumPy при
конвертации в массивы.


## Оценка тензоров


Когда вычислительный граф был построен, ты можешь запустить вычисление, которое
будет производить определенный `tf.Tensor` и извлекать присвоенное ему значение.
Это часто является полезным как для отладки, так и необходимо для работы TensorFlow.


Самый легкий способ оценить тензор - использовать метод `Tensor.eval`. Вот пример
кода оценки тензора:


```python
constant = tf.constant([1, 2, 3])
tensor = constant * constant
print(tensor.eval())
```


Метод `eval` работает только когда активирована стандартная `tf.Session`
(смотри [Графы и сессии](https://www.tensorflow.org/guide/graphs) для
более подробной информации).


`Tensor.eval` возвращает массив NumPy с тем же самым содержимым, что и
тензор.


Иногда невозможно произвести оценку `tf.Tensor` без контекста, потому что
его значение может зависеть от динамичности информации, которая недоступна.
Например, тензоры, которые зависят от `placeholder`' не могут быть оценены
без присвоения значения для `placeholder`.

``` python
p = tf.placeholder(tf.float32)
t = p + 1.0
t.eval()  # Эта операция не будет выполнена, так как нет значения.
t.eval(feed_dict={p:2.0})  # Эта операция будет произведены успешно, поскольку
                           # мы присваиваем значение placeholder.
```


Отемтим, что возможно производить оценку любых `tf.Tensor`, а не только
placeholder.


Другие структуры модели могут усложнить оценку `tf.Tensor`. TensorFlow
не может напрямую оценить `tf.Tensor`, определенные внутри функций или внутри
порядка выполнения структуры модели. Если `tf.Tensor` зависит от значения из
очереди, то оценка `tf.Tensor` будет работать только если какое-то значение
было поставлено в очередь; в других случаях оценка будет приостановлена. При
работе с очередями, всегда вызывай `tf.train.start_queue_runners` прежде чем
производить оценку каких-либо `tf.Tensor`.


## Выводим значения тензоров

 
Чтобы произвести отладку коду возможно понадобится выводить значения `tf.Tensor`.
Несмотря на то, что [tfdbg](../guide/debugger.md) хоть и предлагает углубленную 
поддержку отладки, TensorFlow также имеет операцию для неспоредственного вывода 
значения `tf.Tensor` на экран.


Отметим, что только в редких случаях потребуется использовать следующий
шаблон для вывода значения `tf.Tensor`:


``` python
t = <<здесь определена операция tensorflow>>
print(t)  # Выводим символический тензор при построении графа.
          # Этот тензор не имеет значения в данном контексте.
```


Этот код выведет на экран объект `tf.Tensor` (который представляет из себя
отложенное вычисление), но не его значение. Вместо этого TensorFlow обеспечит
операцию `tf.Print`, которая возвратит его первый неизменный аргумент тензора,
в то время как также выведет набор `tf.Tensor`, который был передан как второй
аргумент.


Чтобы правильно использовать `tf.Print`, необходимо использовать его возвращенное
значение как в примере ниже:


``` python
t = <<какая-либо операция tensorflow>>
tf.Print(t, [t])  # Не возвращает ничего
t = tf.Print(t, [t])  # Здесь мы используем значение, возвращенное `tf.Print`.
result = t + 1  # Теперь результат оценен, и значение `t` будет выведено.
```


При оценке `result` мы также оцениваем все, от чего зависит `result`.
Поскольку `result` зависит от `t` и оценка `t` окажет эффект на вывод его
значения (предыдущего значения `t`), значение `t` будет выведено на экран.

